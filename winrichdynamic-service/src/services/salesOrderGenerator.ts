import connectDB from '@/lib/mongodb';
import Quotation from '@/models/Quotation';
import Order from '@/models/Order';
import { round2 } from '@/utils/number';

interface SalesOrderGenerationOptions {
  requireAdminApproval?: boolean;
  conversionDelay?: number; // hours
  customPaymentMethod?: 'cod' | 'transfer' | 'credit';
  customShippingFee?: number;
  notes?: string;
}

/**
 * Generate a sales order from a quotation
 * @param quotationId - The ID of the quotation to convert
 * @param options - Additional options for sales order generation
 * @returns The created sales order
 */
export async function generateSalesOrderFromQuotation(
  quotationId: string,
  options: SalesOrderGenerationOptions = {}
) {
  await connectDB();
  
  // Find the quotation
  const quotation = await Quotation.findById(quotationId);
  if (!quotation) {
    throw new Error('Quotation not found');
  }

  if (quotation.status !== 'accepted') {
    throw new Error('Quotation must be accepted before converting to sales order');
  }

  // Check if already converted
  if (quotation.convertedToOrder) {
    throw new Error('Quotation already converted to sales order');
  }

  // Check auto-conversion settings if applicable
  if (quotation.autoGenerated && quotation.conversionSettings) {
    const settings = quotation.conversionSettings;
    
    if (settings.requireAdminApproval && !options.requireAdminApproval) {
      throw new Error('Admin approval is required for this conversion');
    }
  }

  // Create sales order data
  const salesOrderData: any = {
    customerName: quotation.customerName,
    customerPhone: quotation.customerPhone,
    items: quotation.items.map((item: any) => ({
      productId: item.productId,
      name: item.productName,
      price: item.unitPrice,
      quantity: item.quantity,
      selectedOptions: item.selectedOptions,
      unitLabel: item.unit,
      unitPrice: item.unitPrice
    })),
    totalAmount: quotation.totalAmount,
    shippingFee: options.customShippingFee || 0,
    discount: quotation.totalDiscount,
    paymentMethod: options.customPaymentMethod || 'cod',
    status: 'confirmed',
    orderType: 'sales_order',
    // Link back to quotation
    sourceQuotationId: quotation._id.toString(),
    sourceOrderId: quotation.sourceOrderId || undefined,
    notes: options.notes || `สร้างจากใบเสนอราคา ${quotation.quotationNumber}`
  };

  // Handle tax invoice information if available
  if (quotation.customerTaxId) {
    salesOrderData.taxInvoice = {
      requestTaxInvoice: true,
      companyName: quotation.customerName,
      taxId: quotation.customerTaxId,
      companyAddress: quotation.customerAddress,
      companyPhone: quotation.customerPhone,
      companyEmail: ''
    };
  }

  // Create sales order (using Order model as sales order)
  const salesOrder = await Order.create(salesOrderData);

  // Update quotation
  await Quotation.findByIdAndUpdate(quotationId, {
    convertedToOrder: salesOrder._id.toString(),
    salesOrderIssued: true,
    salesOrderNumber: `SO${salesOrder._id.toString().slice(-6)}`,
    salesOrderIssuedAt: new Date()
  });

  // If quotation was generated from an order, update that order
  if (quotation.sourceOrderId) {
    await Order.findByIdAndUpdate(quotation.sourceOrderId, {
      quotationStatus: 'accepted',
      linkedSalesOrderId: salesOrder._id.toString(),
      salesOrderGeneratedAt: new Date()
    });
  }

  return salesOrder;
}

/**
 * Check if a quotation meets auto-conversion conditions
 * @param quotation - The quotation to check
 * @returns Whether the quotation can be auto-converted
 */
export async function checkAutoConversionConditions(quotation: any): Promise<boolean> {
  // Must be accepted
  if (quotation.status !== 'accepted') {
    return false;
  }

  // Must not already be converted
  if (quotation.convertedToOrder) {
    return false;
  }

  // Check if auto-conversion is enabled
  if (!quotation.autoConvertToSalesOrder) {
    return false;
  }

  // Check conversion settings
  if (quotation.conversionSettings) {
    const settings = quotation.conversionSettings;
    
    // If auto-convert on acceptance is disabled, return false
    if (!settings.autoConvertOnAcceptance) {
      return false;
    }

    // If admin approval is required, we can't auto-convert
    if (settings.requireAdminApproval) {
      return false;
    }
  }

  return true;
}

/**
 * Schedule sales order creation from quotation
 * @param quotationId - The ID of the quotation
 * @param delayInHours - Delay in hours before conversion
 * @param options - Additional options for sales order generation
 */
export async function scheduleSalesOrderCreation(
  quotationId: string,
  delayInHours: number = 0,
  options: SalesOrderGenerationOptions = {}
) {
  if (delayInHours <= 0) {
    // Convert immediately
    return await generateSalesOrderFromQuotation(quotationId, options);
  }

  // Schedule conversion for later
  const conversionTime = new Date();
  conversionTime.setHours(conversionTime.getHours() + delayInHours);

  // In a real implementation, you would use a job queue like Bull or Agenda
  // For now, we'll just log the scheduled conversion
  console.log(`Scheduled conversion of quotation ${quotationId} to sales order at ${conversionTime}`);
  
  // This would be implemented with a proper job scheduler
  // Example with a simple timeout (not recommended for production):
  setTimeout(async () => {
    try {
      await generateSalesOrderFromQuotation(quotationId, options);
      console.log(`Successfully converted quotation ${quotationId} to sales order`);
    } catch (error) {
      console.error(`Failed to convert quotation ${quotationId} to sales order:`, error);
    }
  }, delayInHours * 60 * 60 * 1000);
}

/**
 * Process auto-conversion for accepted quotations
 * This function would be called periodically to check for quotations that need auto-conversion
 */
export async function processAutoConversions() {
  await connectDB();
  
  try {
    // Find quotations that are accepted and have auto-conversion enabled
    const quotations = await Quotation.find({
      status: 'accepted',
      autoConvertToSalesOrder: true,
      convertedToOrder: { $exists: false },
      'conversionSettings.autoConvertOnAcceptance': true,
      'conversionSettings.requireAdminApproval': false
    });

    for (const quotation of quotations) {
      try {
        // Check if there's a conversion delay
        const delay = quotation.conversionSettings?.conversionDelay || 0;
        
        if (delay > 0) {
          // Calculate when the conversion should happen
          const acceptedAt = quotation.respondedAt || quotation.updatedAt;
          const conversionTime = new Date(acceptedAt);
          conversionTime.setHours(conversionTime.getHours() + delay);
          
          // Check if it's time to convert
          if (new Date() >= conversionTime) {
            await generateSalesOrderFromQuotation(quotation._id.toString());
            console.log(`Auto-converted quotation ${quotation.quotationNumber} to sales order`);
          }
        } else {
          // Convert immediately
          await generateSalesOrderFromQuotation(quotation._id.toString());
          console.log(`Auto-converted quotation ${quotation.quotationNumber} to sales order`);
        }
      } catch (error) {
        console.error(`Failed to auto-convert quotation ${quotation.quotationNumber}:`, error);
      }
    }
  } catch (error) {
    console.error('Error processing auto-conversions:', error);
  }
}

/**
 * Get conversion history for a quotation
 * @param quotationId - The ID of the quotation
 * @returns Conversion history information
 */
export async function getConversionHistory(quotationId: string) {
  await connectDB();
  
  const quotation = await Quotation.findById(quotationId);
  if (!quotation) {
    throw new Error('Quotation not found');
  }

  const history: any = {
    quotation: {
      id: quotation._id,
      number: quotation.quotationNumber,
      createdAt: quotation.createdAt,
      status: quotation.status,
      autoGenerated: quotation.autoGenerated
    },
    sourceOrder: null,
    salesOrder: null,
    conversionEvents: []
  };

  // If quotation was generated from an order
  if (quotation.sourceOrderId) {
    try {
      const sourceOrder = await Order.findById(quotation.sourceOrderId);
      if (sourceOrder) {
        history.sourceOrder = {
          id: sourceOrder._id,
          createdAt: sourceOrder.createdAt,
          totalAmount: sourceOrder.totalAmount,
          status: sourceOrder.status
        };

        history.conversionEvents.push({
          type: 'order_to_quotation',
          timestamp: quotation.quotationGeneratedAt || quotation.createdAt,
          description: `Generated quotation ${quotation.quotationNumber} from order`
        });
      }
    } catch (error) {
      console.warn('Failed to fetch source order:', error);
    }
  }

  // If quotation was converted to sales order
  if (quotation.convertedToOrder) {
    try {
      const salesOrder = await Order.findById(quotation.convertedToOrder);
      if (salesOrder) {
        history.salesOrder = {
          id: salesOrder._id,
          createdAt: salesOrder.createdAt,
          totalAmount: salesOrder.totalAmount,
          status: salesOrder.status
        };

        history.conversionEvents.push({
          type: 'quotation_to_sales_order',
          timestamp: quotation.salesOrderIssuedAt,
          description: `Converted to sales order ${quotation.salesOrderNumber}`
        });
      }
    } catch (error) {
      console.warn('Failed to fetch sales order:', error);
    }
  }

  // Sort events by timestamp
  history.conversionEvents.sort((a: any, b: any) => 
    new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
  );

  return history;
}
