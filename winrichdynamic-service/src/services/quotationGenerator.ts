import connectDB from '@/lib/mongodb';
import Order from '@/models/Order';
import Quotation from '@/models/Quotation';
import Customer from '@/models/Customer';
import Product from '@/models/Product';
import { round2, computeVatIncluded } from '@/utils/number';
import { checkDiscountGuardrails } from '@/utils/pricing';

interface QuotationGenerationOptions {
  autoConvertToSalesOrder?: boolean;
  requireAdminApproval?: boolean;
  conversionDelay?: number; // hours
  customValidityDays?: number; // default 7 days
}

/**
 * Generate a quotation from an order
 * @param orderId - The ID of the order to generate quotation from
 * @param options - Additional options for quotation generation
 * @returns The generated quotation
 */
export async function generateQuotationFromOrder(
  orderId: string,
  options: QuotationGenerationOptions = {}
) {
  await connectDB();
  
  // Find the order
  const order = await Order.findById(orderId);
  if (!order) {
    throw new Error('Order not found');
  }

  // Check if quotation already exists for this order
  if (order.generatedQuotationId) {
    const existingQuotation = await Quotation.findById(order.generatedQuotationId);
    if (existingQuotation) {
      throw new Error('Quotation already exists for this order');
    }
  }

  // Get customer information
  let customerInfo = null;
  try {
    customerInfo = await Customer.findOne({ 
      $or: [
        { phone: order.customerPhone },
        { name: order.customerName }
      ]
    });
  } catch (error) {
    console.warn('Failed to fetch customer info:', error);
  }

  // Generate quotation number
  const today = new Date();
  const year = today.getFullYear();
  const month = String(today.getMonth() + 1).padStart(2, '0');
  
  // Count quotations in this month
  const startOfMonth = new Date(year, today.getMonth(), 1);
  const endOfMonth = new Date(year, today.getMonth() + 1, 0);
  
  const count = await Quotation.countDocuments({
    createdAt: { $gte: startOfMonth, $lte: endOfMonth }
  });
  
  const quotationNumber = `QT${year}${month}${String(count + 1).padStart(3, '0')}`;

  // Convert order items to quotation items
  const quotationItems = [];
  for (const orderItem of order.items) {
    let productInfo = null;
    try {
      productInfo = await Product.findById(orderItem.productId);
    } catch (error) {
      console.warn(`Failed to fetch product info for ${orderItem.productId}:`, error);
    }

    quotationItems.push({
      productId: orderItem.productId.toString(),
      productName: productInfo?.name || orderItem.name,
      description: productInfo?.description || '',
      quantity: orderItem.quantity,
      unit: productInfo?.unit || 'ชิ้น',
      sku: productInfo?.sku || '',
      unitPrice: orderItem.unitPrice || orderItem.price,
      discount: 0, // Default no discount, can be customized later
      totalPrice: (orderItem.unitPrice || orderItem.price) * orderItem.quantity,
      selectedOptions: orderItem.selectedOptions || {}
    });
  }

  // Calculate totals
  const subtotal = quotationItems.reduce((sum, item) => sum + item.totalPrice, 0);
  const totalAmount = subtotal - (order.discount || 0);
  const { vatAmount } = computeVatIncluded(totalAmount, 7); // 7% VAT
  const grandTotal = totalAmount;

  // Set validity date
  const validityDays = options.customValidityDays || 7;
  const validUntil = new Date();
  validUntil.setDate(validUntil.getDate() + validityDays);

  // Create quotation data
  const quotationData: any = {
    quotationNumber,
    customerId: customerInfo?._id?.toString() || 'guest',
    customerCode: customerInfo?.customerCode || '',
    customerName: order.customerName,
    customerTaxId: customerInfo?.taxId || '',
    customerAddress: customerInfo?.companyAddress || '',
    shippingAddress: customerInfo?.shippingAddress || customerInfo?.companyAddress || '',
    shipToSameAsCustomer: true,
    customerPhone: order.customerPhone,
    subject: `ใบเสนอราคาสำหรับคำสั่งซื้อ #${order._id.toString().slice(-6)}`,
    validUntil,
    paymentTerms: order.paymentMethod === 'cod' ? 'เก็บเงินปลายทาง' : 'ชำระเงินก่อนจัดส่ง',
    deliveryTerms: 'จัดส่งภายใน 3-5 วันทำการ',
    items: quotationItems,
    subtotal: round2(subtotal),
    totalDiscount: round2(order.discount || 0),
    totalAmount: round2(totalAmount),
    vatRate: 7,
    vatAmount: round2(vatAmount),
    grandTotal: round2(grandTotal),
    status: 'draft',
    notes: 'สร้างอัตโนมัติจากคำสั่งซื้อออนไลน์',
    
    // Order linkage
    sourceOrderId: order._id.toString(),
    autoGenerated: true,
    autoConvertToSalesOrder: options.autoConvertToSalesOrder || false,
    conversionSettings: {
      autoConvertOnAcceptance: options.autoConvertToSalesOrder || false,
      requireAdminApproval: options.requireAdminApproval !== false, // Default true
      conversionDelay: options.conversionDelay || 0
    }
  };

  // Check discount guardrails
  try {
    const guard = await checkDiscountGuardrails(
      quotationItems.map(item => ({
        productId: item.productId,
        quantity: item.quantity,
        unitPrice: item.unitPrice,
        discount: item.discount
      })),
      {
        role: undefined,
        customerGroup: customerInfo?.customerType || 'default'
      }
    );

    if (!guard.ok) {
      quotationData.approvalStatus = 'pending';
      quotationData.approvalReason = 'ส่วนลดบางรายการไม่เป็นไปตามนโยบาย';
    }
  } catch (error) {
    console.warn('Failed to check discount guardrails:', error);
  }

  // Create quotation
  const quotation = await Quotation.create(quotationData);

  // Update order with quotation information
  await Order.findByIdAndUpdate(orderId, {
    generatedQuotationId: quotation._id.toString(),
    quotationGeneratedAt: new Date(),
    quotationStatus: 'generated',
    autoConvertToSalesOrder: options.autoConvertToSalesOrder || false,
    quotationRequired: true
  });

  return quotation;
}

/**
 * Check if a quotation is required for an order
 * @param order - The order to check
 * @returns Whether a quotation is required
 */
export async function checkIfQuotationRequired(order: any): Promise<boolean> {
  // If order already has a quotation, return false
  if (order.generatedQuotationId) {
    return false;
  }

  // Check if any products in the order require quotations
  for (const item of order.items) {
    try {
      const product = await Product.findById(item.productId);
      if (product && (product as any).requiresQuotation) {
        return true;
      }
    } catch (error) {
      console.warn(`Failed to check product ${item.productId} for quotation requirement:`, error);
    }
  }

  // Check order total threshold
  const totalAmount = order.totalAmount || 0;
  const quotationThreshold = 10000; // Default threshold, can be configurable
  
  if (totalAmount >= quotationThreshold) {
    return true;
  }

  // Check customer type
  try {
    const customer = await Customer.findOne({ 
      $or: [
        { phone: order.customerPhone },
        { name: order.customerName }
      ]
    });
    
    if (customer && (customer as any).requiresQuotation) {
      return true;
    }
  } catch (error) {
    console.warn('Failed to check customer quotation requirement:', error);
  }

  return false;
}

/**
 * Link an order to a quotation
 * @param orderId - The ID of the order
 * @param quotationId - The ID of the quotation
 */
export async function linkOrderToQuotation(orderId: string, quotationId: string) {
  await connectDB();
  
  // Update order
  await Order.findByIdAndUpdate(orderId, {
    generatedQuotationId: quotationId,
    quotationGeneratedAt: new Date(),
    quotationStatus: 'generated'
  });

  // Update quotation
  await Quotation.findByIdAndUpdate(quotationId, {
    sourceOrderId: orderId,
    autoGenerated: false // Manual linking
  });
}

/**
 * Convert a quotation to sales order
 * @param quotationId - The ID of the quotation to convert
 * @returns The created sales order
 */
export async function convertQuotationToSalesOrder(quotationId: string) {
  await connectDB();
  
  const quotation = await Quotation.findById(quotationId);
  if (!quotation) {
    throw new Error('Quotation not found');
  }

  if (quotation.status !== 'accepted') {
    throw new Error('Quotation must be accepted before converting to sales order');
  }

  // Check if already converted
  if (quotation.convertedToOrder) {
    throw new Error('Quotation already converted to sales order');
  }

  // Create sales order data
  const salesOrderData: any = {
    customerName: quotation.customerName,
    customerPhone: quotation.customerPhone,
    items: quotation.items.map((item: any) => ({
      productId: item.productId,
      name: item.productName,
      price: item.unitPrice,
      quantity: item.quantity,
      selectedOptions: item.selectedOptions,
      unitLabel: item.unit,
      unitPrice: item.unitPrice
    })),
    totalAmount: quotation.totalAmount,
    shippingFee: 0, // Can be configured
    discount: quotation.totalDiscount,
    paymentMethod: 'cod', // Default, can be configured
    status: 'confirmed',
    orderType: 'sales_order',
    // Link back to quotation
    sourceQuotationId: quotation._id.toString(),
    sourceOrderId: quotation.sourceOrderId || undefined
  };

  // Create sales order (assuming there's a SalesOrder model)
  // For now, we'll use the Order model as sales order
  const salesOrder = await Order.create(salesOrderData);

  // Update quotation
  await Quotation.findByIdAndUpdate(quotationId, {
    convertedToOrder: salesOrder._id.toString(),
    salesOrderIssued: true,
    salesOrderNumber: `SO${salesOrder._id.toString().slice(-6)}`,
    salesOrderIssuedAt: new Date()
  });

  // If quotation was generated from an order, update that order
  if (quotation.sourceOrderId) {
    await Order.findByIdAndUpdate(quotation.sourceOrderId, {
      quotationStatus: 'accepted',
      linkedSalesOrderId: salesOrder._id.toString(),
      salesOrderGeneratedAt: new Date()
    });
  }

  return salesOrder;
}

/**
 * Schedule automatic conversion of quotation to sales order
 * @param quotationId - The ID of the quotation
 * @param delayInHours - Delay in hours before conversion
 */
export async function scheduleSalesOrderCreation(quotationId: string, delayInHours: number = 0) {
  if (delayInHours <= 0) {
    // Convert immediately
    return await convertQuotationToSalesOrder(quotationId);
  }

  // Schedule conversion for later
  const conversionTime = new Date();
  conversionTime.setHours(conversionTime.getHours() + delayInHours);

  // In a real implementation, you would use a job queue like Bull or Agenda
  // For now, we'll just log the scheduled conversion
  console.log(`Scheduled conversion of quotation ${quotationId} to sales order at ${conversionTime}`);
  
  // This would be implemented with a proper job scheduler
  // Example with a simple timeout (not recommended for production):
  setTimeout(async () => {
    try {
      await convertQuotationToSalesOrder(quotationId);
      console.log(`Successfully converted quotation ${quotationId} to sales order`);
    } catch (error) {
      console.error(`Failed to convert quotation ${quotationId} to sales order:`, error);
    }
  }, delayInHours * 60 * 60 * 1000);
}
